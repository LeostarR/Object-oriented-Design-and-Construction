### Introduction

The overall training objective of the first unit assignments is to model expression structures, experience hierarchical design thinking, and develop iteratively. The three assignments focus on expanding polynomial expressions in the first task, introducing trigonometric functions (sin, cos) and custom functions (f(x), g(x,y), h(x,y,z)) in the second task, and adding differentiation factors (dx(expression)) and allowing function definitions to call other predefined functions in the third task.

You can refer to my code here: [GitHub Repository](https://github.com/LeostarR/Object-oriented-Design-and-Construction)

## Summary of First Assignment

### Design and Architecture

My general approach was divided into three steps:

1. Preprocessing the expression
2. Parsing the expression
3. Converting to a string and printing

#### Preprocessing Expressions

##### `PreStr`

![](https://pic.superbed.cc/item/66ab4785fcada11d3763e8af.png)

Preprocessing includes:

- Removing all consecutive whitespace characters using Java's built-in `replaceAll` method.
- Using a series of `replaceAll` calls to ensure that the string does not contain two or more consecutive '+' or '-' signs (e.g., "----" should be simplified to "+", "+-" to "-").
- Replacing the power symbol "**" with "^" to avoid confusion with multiplication symbols and prevent unnecessary bugs.

#### Parsing Expressions

##### `Lexer`

Processing involves:

![](https://pic.superbed.cc/item/66ab47a8fcada11d3763ebe4.png)

- `read()` ensures that each operand or operator is retrieved at a time.
- `next()` reads the next operand or operator.
- Due to the unpredictable length of numbers, `getNumber()` retrieves the current number.

##### `Ele`

According to the requirements, I created an `Ele` class for storing basic elements. Each `Ele` has the following structure:

![](https://pic.superbed.cc/item/66ab47c1fcada11d3763ed2a.png)

![](https://pic.superbed.cc/item/66ab48f9fcada11d376494b9.png)

- `coe` stores the coefficient of each `Ele`.![](https://pic.superbed.cc/item/66ab47eafcada11d3763f18d.png)
- `hashVar` uses a `HashMap` to store variables and their corresponding powers.

Initially, only `setCoe()`, `getCoe()`, `setHashVar()`, and `getHashVar()` methods were written for setting and getting values. Other methods were added during the overall framework construction.

##### `Expr`

A sequence of expressions looks like this:



Coefficients may carry signs themselves, so they are directly connected by plus signs.

To facilitate data access, I chose an `ArrayList` to store multiple `Ele` objects:

The `Expr` class contains methods such as `initExperList(ArrayList<Ele>)`, `initExpr(Ele)` for initialization, and `getExperlist()` for retrieving the `ArrayList`. Many other methods were completed during the overall construction process.

##### `Parser`

Using recursive descent parsing for expressions:

![](https://pic.superbed.cc/item/66ab4865fcada11d376426ed.png)

Note: `dealEx(Expr)` is part of `parseExpr()`, separated due to method length affecting code style.

1. `parseExpr()` parses expressions, which consist of several terms connected by addition and subtraction operators. The first term may have a positive or negative sign indicating its polarity. Thus, it considers the following structure:



```java
public parseExpr() {
    if (currentSymbol == '+' || currentSymbol == '-') { // An expression's first term can have a sign (+, -)
        parseTerm();
        combTerm();
    } else {
        parseTerm();
        combTerm();
    }
    while (currentSymbol == '+' || currentSymbol == '-') {
        parseTerm();
        combTerm();
    }
    return expr;
}
```

Sign handling is involved, so distinguishing between addition and subtraction within the method isn't necessary; instead, a new combination method `Expr.combTerm(ArrayList<Ele> list, String s)` is used, where `s` represents the sign. If `s` is a minus sign, `Expr.reverseList(ArrayList<Ele> list)` is called to negate, then `addAll()` is used. For performance, simplification occurs after `combTerm` using `merge()` to combine like terms.

1. `parseTerm()` parses terms, which consist of several factors connected by multiplication operators. Similar to above but requires writing a multiplication method `Expr.mulTerm(ArrayList<Ele>)` to multiply two `ArrayList<Ele>` objects (essentially multiple additions).
2. `parseFactor()` parses factors, which include power functions, constant factors, and expression factors.
3. `parsePow()` handles power functions similarly and returns an `Expr` object. Separated due to method length affecting code style.

#### Converting to String and Printing

This primarily manifests in the `toString()` method of the `Expr` class. The idea is to set up a `StringBuilder` and continuously append. Each `Ele` in the `ArrayList` is sequentially checked for '+', whether it is Â±1, if the exponent is 0, and if the whole expression is 0. This section requires special attention to detail.

### Program Structure Analysis Based on Metrics

#### Code Size Analysis

Core code is around 450 lines, with the `Expr` class having the most lines at 175, followed by the `Parser` class with 119 lines.

![](https://pic.superbed.cc/item/66ab4887fcada11d37644047.png)

#### Complexity Analysis

##### Method Complexity

| Method                                            | CogC | ev(G) | iv(G) | v(G) |
| :------------------------------------------------ | :--- | :---- | :---- | :--- |
| DeFun.max(int, int)                               | 0    | 1     | 1     | 1    |
| DeFun.process(String)                             | 22   | 6     | 13    | 13   |
| DeFun.readFun(String)                             | 6    | 3     | 5     | 6    |
| Lexer.Lexer(String)                               | 0    | 1     | 1     | 1    |
| Lexer.getNumber()                                 | 2    | 1     | 3     | 3    |
| Lexer.next()                                      | 5    | 2     | 3     | 6    |
| Lexer.read()                                      | 0    | 1     | 1     | 1    |
| MainClass.main(String[])                          | 2    | 1     | 3     | 3    |
| Parser.Parser(Lexer)                              | 0    | 1     | 1     | 1    |
| Parser.dealEx(Expr)                               | 0    | 1     | 1     | 1    |
| Parser.parseExpr()                                | 5    | 1     | 5     | 5    |
| Parser.parseFactor()                              | 18   | 5     | 11    | 12   |
| Parser.parsePow()                                 | 2    | 1     | 2     | 2    |
| Parser.parseTerm()                                | 9    | 1     | 6     | 7    |
| Parser.parseTri()                                 | 8    | 1     | 4     | 4    |
| PreStr.pre(String)                                | 6    | 1     | 6     | 7    |
| expr.Ele.Ele()                                    | 0    | 1     | 1     | 1    |
| expr.Ele.canMerge(Ele)                            | 4    | 1     | 4     | 6    |
| expr.Ele.compareTo(Object)                        | 27   | 13    | 12    | 13   |
| expr.Ele.getCoe()                                 | 0    | 1     | 1     | 1    |
| expr.Ele.getHashCos()                             | 0    | 1     | 1     | 1    |
| expr.Ele.getHashSin()                             | 0    | 1     | 1     | 1    |
| expr.Ele.getHashVar()                             | 0    | 1     | 1     | 1    |
| expr.Ele.initHashCos(HashMap<String, BigInteger>) | 0    | 1     | 1     | 1    |
| expr.Ele.initHashSin(HashMap<String, BigInteger>) | 0    | 1     | 1     | 1    |
| expr.Ele.initHashVar(HashMap<String, BigInteger>) | 0    | 1     | 1     | 1    |
| expr.Ele.isOne()                                  | 6    | 1     | 5     | 8    |
| expr.Ele.isZero()                                 | 0    | 1     | 1     | 1    |
| expr.Ele.putHashCos(HashMap<String, BigInteger>)  | 4    | 1     | 3     | 3    |
| expr.Ele.putHashSin(HashMap<String, BigInteger>)  | 4    | 1     | 3     | 3    |
| expr.Ele.setCoe(BigInteger)                       | 0    | 1     | 1     | 1    |
| expr.Ele.setHashCos(String, BigInteger)           | 0    | 1     | 1     | 1    |
| expr.Ele.setHashSin(String, BigInteger)           | 0    | 1     | 1     | 1    |
| expr.Ele.setHashVar(String, BigInteger)           | 0    | 1     | 1     | 1    |
| expr.Ele.zero()                                   | 0    | 1     | 1     | 1    |
| expr.Expr.combTerm(ArrayList, String)             | 1    | 1     | 2     | 2    |
| expr.Expr.getExprList()                           | 0    | 1     | 1     | 1    |
| expr.Expr.initExpr(Ele)                           | 0    | 1     | 1     | 1    |
| expr.Expr.initExprList(ArrayList)                 | 0    | 1     | 1     | 1    |
| expr.Expr.merge()                                 | 10   | 4     | 7     | 7    |
| expr.Expr.mulTerm(ArrayList)                      | 3    | 1     | 3     | 3    |
| expr.Expr.reverse()                               | 1    | 1     | 2     | 2    |
| expr.Expr.reverseList(ArrayList)                  | 1    | 1     | 2     | 2    |
| expr.Expr.simplify()                              | 4    | 3     | 4     | 4    |
| expr.Expr.sort()                                  | 32   | 13    | 12    | 13   |
| expr.Expr.toString()                              | 16   | 1     | 10    | 11   |
| expr.Expr.triStr(Ele)                             | 14   | 1     | 11    | 11   |
| expr.Expr.varStr(Ele)                             | 21   | 1     | 16    | 16   |
| expr.Term.getTermList()                           | 0    | 1     | 1     | 1    |
| Total                                             | 233  | 90    | 180   | 195  |
| Average                                           | 4.75 | 1.83  | 3.67  | 3.97 |

##### Class Complexity

![](https://pic.superbed.cc/item/66ab4967fcada11d3764e765.png)

The diagram shows that the most complex methods are `Parser.parseFactor()`, `expr.Expr.toString()`, and `expr.Expr.varStr(Ele)`. The complexity increases significantly for these methods because they handle multiple types of factors and string conversion scenarios.

The diagram also highlights that the `Expr`, `Ele`, and `Parser` classes have higher complexity due to the numerous methods for decomposition and calculation/merging.

###### Attached: Metric Analysis Item Explanations

- CogC: Cognitive Complexity
- ev(G): Basic complexity of non-abstract methods, measures control flow structure defects, range [1, v(G)]
- iv(G): Design complexity of methods, measures coupling between method control flows and other methods, range [1, v(G)]
- v(G): Cyclomatic complexity of non-abstract methods, measures the number of different execution paths within each method
- OC: Non-abstract method cyclomatic complexity of classes, excluding inherited classes
- WMC: Total cyclomatic complexity of classes

#### UML Class Diagram

Each class design consideration has been explained in the previous sections, so it will not be repeated here.

![](https://pic.superbed.cc/item/66ab48bafcada11d37646547.jpg)

## Summary of Second Assignment

### Design and Architecture

New requirements for this assignment included:

- Supporting nested multi-level parentheses.
- Adding trigonometric factor support, with any factor inside trigonometric function parentheses.
- Introducing custom function factors, though custom function expressions do not call other functions.

Based on the first assignment, the following tasks needed to be accomplished:

1. Replace custom functions.
2. Introduce new data structures to store trigonometric factors.
3. Add or improve methods to complete trigonometric function calculations and simplifications.

#### Replacing Custom Functions

##### `DeFun`

Implementation of replacement allows for expression parsing using the previously implemented recursive descent:

![](https://pic.superbed.cc/item/66ab48d0fcada11d376472dd.png)

- Splitting the string by '=' to find formal parameters from the left side and storing them along with the right-side expression in a `HashMap`.
- Replacing all custom functions in the original expression through `process()`.

#### Handling Trigonometric Factors

##### `Ele`

Each `Ele` type now looks like this:

![](https://pic.superbed.cc/item/66ab48e7fcada11d376484ba.png)

Trigonometric factors inside parentheses are converted to strings as keys, with exponents as values stored in a `HashMap`.

Methods for handling trigonometric factors have been added:

![](https://pic.superbed.cc/item/66ab48f9fcada11d376494b9.png)

##### `Expr`

Addition and multiplication require only adding trigonometric factor operations on top of existing logic (addition and multiplication need additional conditions in `canMerge()`).

![](https://pic.superbed.cc/item/66ab492efcada11d3764be2f.png)

In `toString()`, a method `triStr(Ele)` for printing trigonometric factors is added.

### Program Structure Analysis Based on Metrics

#### Code Size Analysis

Core code is around 742 lines, with the `Expr` class having the most lines at 259, followed by the `Parser` class with 150 lines.

![](https://pic.superbed.cc/item/66ab494cfcada11d3764d335.png)

#### Complexity Analysis

##### Method Complexity

| Method                                            | CogC | ev(G) | iv(G) | v(G) |
| :------------------------------------------------ | :--- | :---- | :---- | :--- |
| DeFun.max(int, int)                               | 0    | 1     | 1     | 1    |
| DeFun.process(String)                             | 22   | 6     | 13    | 13   |
| DeFun.readFun(String)                             | 6    | 3     | 5     | 6    |
| Lexer.Lexer(String)                               | 0    | 1     | 1     | 1    |
| Lexer.getNumber()                                 | 2    | 1     | 3     | 3    |
| Lexer.next()                                      | 5    | 2     | 3     | 6    |
| Lexer.read()                                      | 0    | 1     | 1     | 1    |
| MainClass.main(String[])                          | 2    | 1     | 3     | 3    |
| Parser.Parser(Lexer)                              | 0    | 1     | 1     | 1    |
| Parser.dealEx(Expr)                               | 0    | 1     | 1     | 1    |
| Parser.parseExpr()                                | 5    | 1     | 5     | 5    |
| Parser.parseFactor()                              | 18   | 5     | 11    | 12   |
| Parser.parsePow()                                 | 2    | 1     | 2     | 2    |
| Parser.parseTerm()                                | 9    | 1     | 6     | 7    |
| Parser.parseTri()                                 | 8    | 1     | 4     | 4    |
| PreStr.pre(String)                                | 6    | 1     | 6     | 7    |
| expr.Ele.Ele()                                    | 0    | 1     | 1     | 1    |
| expr.Ele.canMerge(Ele)                            | 4    | 1     | 4     | 6    |
| expr.Ele.compareTo(Object)                        | 27   | 13    | 12    | 13   |
| expr.Ele.getCoe()                                 | 0    | 1     | 1     | 1    |
| expr.Ele.getHashCos()                             | 0    | 1     | 1     | 1    |
| expr.Ele.getHashSin()                             | 0    | 1     | 1     | 1    |
| expr.Ele.getHashVar()                             | 0    | 1     | 1     | 1    |
| expr.Ele.initHashCos(HashMap<String, BigInteger>) | 0    | 1     | 1     | 1    |
| expr.Ele.initHashSin(HashMap<String, BigInteger>) | 0    | 1     | 1     | 1    |
| expr.Ele.initHashVar(HashMap<String, BigInteger>) | 0    | 1     | 1     | 1    |
| expr.Ele.isOne()                                  | 6    | 1     | 5     | 8    |
| expr.Ele.isZero()                                 | 0    | 1     | 1     | 1    |
| expr.Ele.putHashCos(HashMap<String, BigInteger>)  | 4    | 1     | 3     | 3    |
| expr.Ele.putHashSin(HashMap<String, BigInteger>)  | 4    | 1     | 3     | 3    |
| expr.Ele.setCoe(BigInteger)                       | 0    | 1     | 1     | 1    |
| expr.Ele.setHashCos(String, BigInteger)           | 0    | 1     | 1     | 1    |
| expr.Ele.setHashSin(String, BigInteger)           | 0    | 1     | 1     | 1    |
| expr.Ele.setHashVar(String, BigInteger)           | 0    | 1     | 1     | 1    |
| expr.Ele.zero()                                   | 0    | 1     | 1     | 1    |
| expr.Expr.combTerm(ArrayList, String)             | 1    | 1     | 2     | 2    |
| expr.Expr.getExprList()                           | 0    | 1     | 1     | 1    |
| expr.Expr.initExpr(Ele)                           | 0    | 1     | 1     | 1    |
| expr.Expr.initExprList(ArrayList)                 | 0    | 1     | 1     | 1    |
| expr.Expr.merge()                                 | 10   | 4     | 7     | 7    |
| expr.Expr.mulTerm(ArrayList)                      | 3    | 1     | 3     | 3    |
| expr.Expr.reverse()                               | 1    | 1     | 2     | 2    |
| expr.Expr.reverseList(ArrayList)                  | 1    | 1     | 2     | 2    |
| expr.Expr.simplify()                              | 4    | 3     | 4     | 4    |
| expr.Expr.sort()                                  | 32   | 13    | 12    | 13   |
| expr.Expr.toString()                              | 16   | 1     | 10    | 11   |
| expr.Expr.triStr(Ele)                             | 14   | 1     | 11    | 11   |
| expr.Expr.varStr(Ele)                             | 21   | 1     | 16    | 16   |
| expr.Term.getTermList()                           | 0    | 1     | 1     | 1    |
| Total                                             | 233  | 90    | 180   | 195  |
| Average                                           | 4.75 | 1.83  | 3.67  | 3.97 |

### Class Complexity



![Class Complexity](https://pic.superbed.cc/item/66ab4967fcada11d3764e765.png)



#### UML Class Diagram



![UML Class Diagram](https://pic.superbed.cc/item/66ab4989fcada11d37650132.jpg)



The design considerations for each class have been explained in the previous sections on design and architecture, so they will not be repeated here.

## Summary of Third Assignment

### Design and Architecture

For this assignment, new requirements were introduced:

- Custom function definitions can now call other predefined custom functions.
- A differentiation factor has been added.

Based on the second assignment, the following tasks needed to be completed:

1. Improve methods in the `DeFun` class to support calling previously defined custom functions and include differentiation factors.
2. Add a differentiation method in the `Expr` class.

#### Improving the Replacement of Custom Functions

##### `DeFun`

Replace custom functions that already exist in the HashMap within the same class, then replace the differentiation factors (according to the assignment requirements, simplification and replacement of differentiation factors need to occur at this stage). Therefore, we directly reuse the Parser class to parse the expression inside the differentiation factor and use `toString()` to replace the original differentiation factor.

Below is an example snippet:

```java
if (str.contains("d")) { // Differentiation factor appears only once
    int begin = str.indexOf("d");
    // subString = dx(expression) | dy(expression) | dz(expression), which is the differentiation factor
    String subString = sim.substring(/* extract the substring inside dx() or dy() or dz() */);
    String derFact = subString.substring(2); // derFact is the expression to differentiate
    parser.parseExpr(); // Preprocess, parse, return an Expr object
    expr.derExpr(); // Differentiate the expression inside the parentheses, returning an Expr object
    str = str.replace(subString, "(" + expr + ")"); // Remove (replace) the entire differentiation factor
}
```

#### Adding Differentiation Methods

##### `Ele`

In the `Ele` class, add methods to check if it contains a specific variable ('x', 'y', 'z'). If it does not contain the variable, the result of differentiation should be zero; otherwise, perform normal differentiation.

![](https://pic.superbed.cc/item/66ab49b0fcada11d37651f94.png)

##### `Expr`

Add support for differentiation methods where `derExpr(char)` differentiates with respect to the parameter `char` as the independent variable, separately differentiating each `Ele`'s variable part and trigonometric factor part before combining them.

![](https://pic.superbed.cc/item/66ab49c5fcada11d37652fa1.png)

### Program Structure Analysis Based on Metrics

#### Code Size Analysis

Core code is around 899 lines, with the `Expr` class having the most lines at 370, followed by the `Parser` class with 173 lines.

![](https://pic.superbed.cc/item/66ab49dcfcada11d376541d1.png)

#### Complexity Analysis

##### Method Complexity

| Method                                       | CogC | ev(G) | iv(G) | v(G) |
| :------------------------------------------- | :--- | :---- | :---- | :--- |
| DeFun.findRi(int, String)                    | 9    | 5     | 6     | 6    |
| DeFun.max(int, int)                          | 0    | 1     | 1     | 1    |
| DeFun.process(String)                        | 10   | 1     | 8     | 8    |
| DeFun.readFun(String)                        | 7    | 3     | 6     | 7    |
| Ele.Ele()                                    | 0    | 1     | 1     | 1    |
| Ele.canMerge(Ele)                            | 4    | 1     | 4     | 6    |
| Ele.compareTo(Object)                        | 27   | 13    | 12    | 13   |
| Ele.cosContain(String)                       | 3    | 3     | 2     | 3    |
| Ele.getCoe()                                 | 0    | 1     | 1     | 1    |
| Ele.getHashCos()                             | 0    | 1     | 1     | 1    |
| Ele.getHashSin()                             | 0    | 1     | 1     | 1    |
| Ele.getHashVar()                             | 0    | 1     | 1     | 1    |
| Ele.initHashCos(HashMap<String, BigInteger>) | 0    | 1     | 1     | 1    |
| Ele.initHashSin(HashMap<String, BigInteger>) | 0    | 1     | 1     | 1    |
| Ele.initHashVar(HashMap<String, BigInteger>) | 0    | 1     | 1     | 1    |
| Ele.isOne()                                  | 6    | 1     | 5     | 8    |
| Ele.isZero()                                 | 0    | 1     | 1     | 1    |
| Ele.putHashCos(HashMap<String, BigInteger>)  | 4    | 1     | 3     | 3    |
| Ele.putHashSin(HashMap<String, BigInteger>)  | 4    | 1     | 3     | 3    |
| Ele.setCoe(BigInteger)                       | 0    | 1     | 1     | 1    |
| Ele.setHashCos(String, BigInteger)           | 0    | 1     | 1     | 1    |
| Ele.setHashSin(String, BigInteger)           | 0    | 1     | 1     | 1    |
| Ele.setHashVar(String, BigInteger)           | 0    | 1     | 1     | 1    |
| Ele.sinContain(String)                       | 3    | 3     | 2     | 3    |
| Ele.varContain(String)                       | 1    | 1     | 1     | 2    |
| Ele.zero()                                   | 0    | 1     | 1     | 1    |
| Expr.combTerm(ArrayList, String)             | 1    | 1     | 2     | 2    |
| Expr.derCos(int, String)                     | 7    | 1     | 5     | 5    |
| Expr.derExpr(char)                           | 14   | 1     | 8     | 8    |
| Expr.derSin(int, String)                     | 7    | 1     | 5     | 5    |
| Expr.derVar(int, String)                     | 0    | 1     | 1     | 1    |
| Expr.getExprList()                           | 0    | 1     | 1     | 1    |
| Expr.initExpr(Ele)                           | 0    | 1     | 1     | 1    |
| Expr.initExprList(ArrayList)                 | 0    | 1     | 1     | 1    |
| Expr.merge()                                 | 10   | 4     | 7     | 7    |
| Expr.mulTerm(ArrayList)                      | 3    | 1     | 3     | 3    |
| Expr.reverse()                               | 1    | 1     | 2     | 2    |
| Expr.reverseList(ArrayList)                  | 1    | 1     | 2     | 2    |
| Expr.simplify()                              | 4    | 3     | 4     | 4    |
| Expr.sort()                                  | 32   | 13    | 12    | 13   |
| Expr.toString()                              | 16   | 1     | 10    | 11   |
| Expr.triStr(Ele)                             | 22   | 1     | 13    | 13   |
| Expr.varStr(Ele)                             | 21   | 1     | 16    | 16   |
| Lexer.Lexer(String)                          | 0    | 1     | 1     | 1    |
| Lexer.getNumber()                            | 2    | 1     | 3     | 3    |
| Lexer.next()                                 | 6    | 2     | 6     | 7    |
| Lexer.read()                                 | 0    | 1     | 1     | 1    |
| MainClass.main(String[])                     | 2    | 1     | 3     | 3    |
| Parser.Parser(Lexer)                         | 0    | 1     | 1     | 1    |
| Parser.dealEx(Expr)                          | 0    | 1     | 1     | 1    |
| Parser.parseDer(char)                        | 0    | 1     | 1     | 1    |
| Parser.parseExpr()                           | 5    | 1     | 5     | 5    |
| Parser.parseFactor()                         | 20   | 6     | 14    | 15   |
| Parser.parsePow()                            | 2    | 1     | 2     | 2    |
| Parser.parseTerm()                           | 9    | 1     | 6     | 7    |
| Parser.parseTri()                            | 8    | 1     | 4     | 4    |
| PreStr.pre(String)                           | 6    | 1     | 6     | 7    |
| Total                                        | 277  | 102   | 214   | 230  |
| Average                                      | 4.85 | 1.79  | 3.75  | 4.04 |

##### Class Complexity



![Class Complexity](https://pic.superbed.cc/item/66ab49f4fcada11d3765538f.png)



The diagram shows that the `Expr`, `Ele`, and `Parser` classes have higher complexity due to the numerous simplification, calculation, and differentiation methods within the `Expr` class.

#### UML Class Diagram



![UML Class Diagram](https://pic.superbed.cc/item/66ab4a0bfcada11d37656557.jpg)



The design considerations for each class have been explained in the previous sections on design and architecture, so they will not be repeated here.

## Bug Analysis

### Analyzing Bugs in My Program

##### First Assignment

- Special cases such as `0^0+5^0+2*10^0` required debugging and modifications in `toString()`.

##### Second Assignment

- When replacing custom functions based on commas, there could be errors when handling nested functions like `f(g(y,z),h(x,y),sin(x))` with more than two commas. The solution was to find and replace the last custom function in each loop (ensuring no nested custom functions are inside).
- Pay attention to index positions during replacement, e.g., `f((((x,y,z))))` might cause bracket judgment errors.
- Handle special and edge cases, such as `sin((0))^2`, `sin((0))^0`, `cos((0))^3`.
- When the exponent is 0, directly read the integer rather than parsing the subsequent expression.

##### Third Assignment

- Simplification after differentiation caused issues, e.g., `dx(x*cos(x)**0)` would result in incorrect output even though the parsed `Expr` was correct. This was because checking if the cosine part contains `x` relied on whether the `HashMap` was empty (leftover from the second assignment), but I did not remove entries accordingly after differentiation, leading to incorrect output.

### Analyzing Bugs in Others' Programs

Manually construct representative boundary data with multiple levels of nested parentheses and special conditions (results being 0, 1, or no independent variable inside the differentiation), such as:

```javascript
1
f(x,y)=(((sin(cos(x))-(+1-sin(cos(y))))))
f((sin(x)),(y**2-0**0))+cos(0)**0-sin(0)**0
0
dx(x*cos(x)**0)
```

## Reflection

The first unit assignments focused on iterative development of expanding expressions and differentiation over three iterations. Initially struggling with understanding the role of Git, I gradually recognized the importance of version control in projects. From feeling lost with IDEA and making frequent mistakes to appreciating its powerful features, and from unfamiliarity with Java to becoming acquainted with its many convenient methods, data structures, and object-oriented thinking. Additionally, the emphasis on coding style has made me increasingly aware of its importance and improved my programming style. The first assignment was challenging due to the lack of knowledge about Java syntax and data structures. Iterative development in the second and third assignments was easier than starting from scratch, but extra care had to be taken to minimize coupling between classes and methods, avoiding changes to existing methods to make bug detection easier. Lastly, reviewing classmates' design ideas in discussion areas greatly assisted my architectural design. Thank you to the teaching assistants and fellow students for your enthusiastic help!

---



## ä»ç»

ç¬¬ä¸ååä½ä¸æ»çè®­ç»ç®æ æ¯å¯¹è¡¨è¾¾å¼ç»æè¿è¡å»ºæ¨¡ï¼ä½ä¼å±æ¬¡åçææ³ï¼ä¸æ¬¡ä½ä¸ä¸ºè¿­ä»£å¼åãç¬¬ä¸æ¬¡ä½ä¸æ¯å®æå¯¹å¤é¡¹å¼æ¬å·çå±å¼ï¼ç¬¬äºæ¬¡ä½ä¸æ°å¼å¥äºä¸è§å½æ°(sin,cos)ä»¥åèªå®ä¹å½æ°(f(x),g(x,y),h(x,y,z))ï¼ç¬¬ä¸æ¬¡ä½ä¸æ°å¢æ±å¯¼å å­(dx(è¡¨è¾¾å¼))å¹¶åè®¸å½æ°å®ä¹æ¶è°ç¨å¶ä»å·²å®ä¹è¿çå½æ°ã

ç¹å»æ­¤å¤å¯ä»¥åèæçä»£ç ï¼https://github.com/LeostarR/Object-oriented-Design-and-Construction

## ç¬¬ä¸æ¬¡ä½ä¸æ»ç»

### è®¾è®¡ä¸æ¶æ

æçæ»æè·¯åä¸ºä¸æ­¥ï¼

1. é¢å¤çè¡¨è¾¾å¼
2. è§£æè¡¨è¾¾å¼
3. è½¬åä¸ºå­ç¬¦ä¸²å¹¶æå°

#### é¢å¤çè¡¨è¾¾å¼

##### `PreStr`

é¢å¤çï¼

![](https://pic.superbed.cc/item/66ab4785fcada11d3763e8af.png)

- å»é¤ææè¿ç»­çç©ºç½å­ç¬¦ï¼ç¨Javaèªå¸¦çæ¹æ³`replaceAll`å³å¯è§£å³ï¼
- éè¿ä¸ç³»å`replaceAll`ä½¿å¾å­ç¬¦ä¸²ä¸å«æè¿ç»­çä¸¤ä¸ªåä»¥ä¸ç'+'å'-'ï¼ä¾å¦"----"åºåä¸º"+"ï¼"+-"åºåä¸º"-"ï¼
- å°è¡¨ç¤ºå¹æ¬¡ç"**"æ¿æ¢ä¸º"^"ï¼é²æ­¢ä¸ä¹å·å¼æ··ï¼äº§çä¸å¿è¦çbug

#### è§£æè¡¨è¾¾å¼

##### `Lexer`

è¯»åå¤çï¼

![](https://pic.superbed.cc/item/66ab47a8fcada11d3763ebe4.png)

- `read()`è½å¤ä¿è¯æ¯æ¬¡ååºå½åçæä½æ°æèè¿ç®ç¬¦
- `next()`è½å¤å¾åè¯»ä¸ä¸ªæä½æ°æèè¿ç®ç¬¦
- ç±äºæ°å­é¿åº¦çä¸ç¡®å®ï¼ä½¿ç¨`getNumber()`è½å¤ååºå½åæ°å­

##### `Ele`

æ ¹æ®é¢ç®è¦æ±ï¼æéæ©æ°å»ºä¸ä¸ª`Ele`ç±»å®æå¯¹åºæ¬åç´ çå­å¨ï¼æ¯ä¸ä¸ª`Ele`åºå½¢å¦ï¼

![](https://pic.superbed.cc/item/66ab47c1fcada11d3763ed2a.png)

![](https://pic.superbed.cc/item/66ab47dbfcada11d3763f065.png)

`coe`å­å¨æ¯ä¸ä¸ª`Ele`çç³»æ°ï¼`hashVar`éè¿`HashMap`å­å¨åéåå¶å¯¹åºå¹æ¬¡ã

![](https://pic.superbed.cc/item/66ab47eafcada11d3763f18d.png)

åå¼å§å`Ele`æ¶åªåäº`setCoe()`,`getCoe()`,`setHashVar()`,`getHashVar()`åä¸ªæ¹æ³ç¨äºè®¾å®å¼ååå¼ï¼å¶ä»æ¹æ³æ¯å¨åç»­æ¡æ¶çæ´ä½æ­å»ºä¸­ä¹¦åçï¼å æ­¤æ¾å°åé¢è®²è§£ã

##### `Expr`

ä¸è¿ä¸²çè¡¨è¾¾å¼å½¢å¦ï¼

![](https://pic.superbed.cc/item/66ab480ffcada11d3763f56f.png)

æ­¤å¤ç³»æ°æ¬èº«æ¯å¯è½å¸¦ç¬¦å·çï¼å æ­¤ç´æ¥ç¨å å·ç¸è¿ã

ä¸ºäºæ¹ä¾¿æ°æ®çè°ç¨ï¼æéæ©`ArrayList`æ¥å­å¨å¤ä¸ª`Ele`ï¼

![](https://pic.superbed.cc/item/66ab4831fcada11d3763fee0.png)

`Expr`æ¹æ³ä¸­ï¼`initExperList(ArrayList<Ele>)`,`initExpr(Ele)`ç¨äºåå§åï¼`getExperlist()`ç¨äºååºè¯¥`ArrayList`ï¼å¶ä»å¾å¤æ¹æ³æ¯å¨æå»ºæ´ä½çè¿ç¨ä¸­å®æçï¼å æ­¤ä¹æ¾å°åé¢ã

![](https://pic.superbed.cc/item/66ab484cfcada11d3764139a.png)

##### `Parser`

ä½¿ç¨éå½ä¸éè§£æè¡¨è¾¾å¼ï¼

![](https://pic.superbed.cc/item/66ab4865fcada11d376426ed.png)

æ³¨ï¼`dealEx(Expr)`æ¯`parseExpr()`çä¸é¨åï¼åç¦»åºæ¥æ¯å ä¸ºæ¹æ³è¿é¿å½±åç é£:ï¼

1.`parseExpr()`ç¨äºè§£æè¡¨è¾¾å¼ï¼æ ¹æ®å®ä¹ï¼è¡¨è¾¾å¼ç±å æ³ååæ³è¿ç®ç¬¦è¿æ¥è¥å¹²é¡¹ç»æå¹¶ä¸å¨ç¬¬ä¸é¡¹ä¹åï¼å¯ä»¥å¸¦ä¸ä¸ªæ­£å·æèè´å·ï¼è¡¨ç¤ºç¬¬ä¸ä¸ªé¡¹çæ­£è´ï¼å æ­¤èèå¦ä¸ç»æã

```java
public parseExpr() {
        if (å½åç¬¦å· == '+' || å½åç¬¦å· == '-') { //è¡¨è¾¾å¼çç¬¬ä¸ä¸ªé¡¹å¯ä»¥æç¬¦å·ï¼+ï¼-ï¼
            parseTerm();
            combTerm();
        } else {
            parseTerm();
            combTerm();
        }
        while (å½åç¬¦å· == '+' || å½åç¬¦å· == '-') {
            parseTerm();
            combTerm();
        }
        return expr;
    }
```

æ­¤å¤æ¶åå°æ­£è´å·çå¤çï¼å æ­¤ä¸å¨æ¹æ³ä¸­åºåå åï¼èæ¯æ°å»ºåå¹¶çæ¹æ³`Expr.combTerm(ArrayList<Ele> list, String s)`ï¼`s`ä»£è¡¨ç¬¦å·ãè¥`s`ä¸ºè´å·ï¼å°±éè¿`Expr.reverseList(ArrayList<Ele> list)`ååï¼ç¶åä½¿ç¨`addAll()`ï¼èèæ§è½ï¼æä»¬éè¦åç®ï¼å¨`combTerm`ä¹åä½¿ç¨`merge()`åå¹¶åç±»é¡¹ã

2.`parseTerm()`ç¨äºè§£æé¡¹ï¼é¡¹ç±ä¹æ³è¿ç®ç¬¦è¿æ¥è¥å¹²å å­ç»æï¼æ»ä½æ¶æä¸ä¸æç¸ä¼¼ï¼åªæ¯è¦éæ°åä¸ä¸ªä¹æ³çæ¹æ³ï¼ä¹å°±æ¯`Expr.mulTerm(ArrayList<Ele>)`è½å¤å®ç°ä¸¤ä¸ª`ArrayList<Ele>`çç¸ä¹ï¼å®éä¸å°±æ¯å¤ä¸ªç¸å ï¼ã

3.`parseFactor()`ç¨äºè§£æå å­ãç±å®ä¹ç¥ï¼å å­åæ¬å¹å½æ°ï¼å¸¸æ°å å­åè¡¨è¾¾å¼å å­ã

```java
public parseFactor() {
        if (ç¬¦å· == '(') { //è¡¨è¾¾å¼å å­ï¼å½æ°è¡¨è¾¾å¼ï¼å·²å¨PreSträ¸­å¥ä¸äºä¸å±æ¬å·ï¼å æ­¤ä¹å¯ä»¥å½æè¡¨è¾¾å¼å å­å¤çï¼
            parseExpr();
            if (ä¸ä¸ä¸ªç¬¦å·æ¯'^') { //ä¸ä¸ä¸ªä¸å®ä¸ºææ°
                //è¯»å¥ä¸ä¸ä¸ªæ´æ°n;
                if (n == 0) { //èèç¹æ®æåµ
                    //ç½®1;
                } else {
                    //éå¤çä¹åè¡¨è¾¾å¼n-1æ¬¡;
                }
            }
            return expr;
        } else if (ç¬¦å· == '+' || ç¬¦å· == '-') { //ä¸æ¯ç¬¬ä¸ä¸ªå¸¦ç¬¦å·çå å­ï¼åä¸å®ä¸ºæç¬¦å·å¸¸æ°
            //è¯»å¥å¸¸æ°nå¹¶ç»åå½åç¬¦å·;
            return expr;
        } else if (ç¬¦å·ä¸ºæ°å­) { //å¤çæ ç¬¦å·æ´æ°
           // è¯»å¥å¸¸æ°n;
            return expr;
        } else { //å¤çå¹å½æ°
            return  parsePow();
        }
    }
```

4.`parsePow()`åä¸æåæ¯ä¸æ ·ï¼ç¨äºè§£æå¹å½æ°ï¼å¹¶è¿åä¸ä¸ª`Expr`ç±»ãè¿éåç¬åæ¯å ä¸ºæ¹æ³è¡æ°å¤ªå¤å½±åç é£ï¼)

#### è½¬åä¸ºå­ç¬¦ä¸²å¹¶æå°

è¿ä¸ç¹ä¸»è¦ä½ç°å¨`Expr`ç±»ä¸­ç`toString()`æ¹æ³ãæ»çæè·¯æ¯è®¾ç½®`StringBuilder`ç¶åä¸æ­`append`ãå¯¹`ArrayList`ä¸­çæ¯ä¸ä¸ª`Ele`ä¾æ¬¡å¤æ­æ¯å¦æ'+'ï¼æ¯å¦ä¸ºæ­£è´1ï¼å¹æ¬¡æ¯å¦ä¸º0ï¼æ´ä½æ¯å¦ä¸º0ãï¼è¿ä¸é¨åç»èè¿æºå¤çéè¦ç¹å«æ³¨æï¼

### åºäºåº¦éçç¨åºç»æåæ

#### ä»£ç è§æ¨¡åæ

![](https://pic.superbed.cc/item/66ab4887fcada11d37644047.png)

æ ¸å¿ä»£ç å¨450è¡å·¦å³ï¼`Expr`ç±»è¡æ°æå¤ï¼å å°äº175è¡ï¼å¶æ¬¡æ¯119è¡çè§£æ`Parser`ç±»ã

#### å¤æåº¦åæ

##### æ¹æ³å¤æåº¦

| Method                                            | CogC | ev(G) | iv(G) | v(G) |
| :------------------------------------------------ | :--- | :---- | :---- | :--- |
| Lexer.Lexer(String)                               | 0    | 1     | 1     | 1    |
| Lexer.getNumber()                                 | 2    | 1     | 3     | 3    |
| Lexer.next()                                      | 3    | 2     | 3     | 4    |
| Lexer.read()                                      | 0    | 1     | 1     | 1    |
| MainClass.main(String[])                          | 0    | 1     | 1     | 1    |
| Parser.Parser(Lexer)                              | 0    | 1     | 1     | 1    |
| Parser.dealEx(Expr)                               | 0    | 1     | 1     | 1    |
| Parser.parseExpr()                                | 5    | 1     | 5     | 5    |
| Parser.parseFactor()                              | 16   | 4     | 9     | 10   |
| Parser.parsePow()                                 | 2    | 1     | 2     | 2    |
| Parser.parseTerm()                                | 9    | 1     | 6     | 7    |
| PreStr.pre(String)                                | 6    | 1     | 6     | 7    |
| expr.Ele.Ele()                                    | 0    | 1     | 1     | 1    |
| expr.Ele.canMerge(Ele)                            | 2    | 1     | 3     | 4    |
| expr.Ele.compareTo(Object)                        | 7    | 5     | 5     | 5    |
| expr.Ele.getCoe()                                 | 0    | 1     | 1     | 1    |
| expr.Ele.getHashVar()                             | 0    | 1     | 1     | 1    |
| expr.Ele.initHashVar(HashMap<String, BigInteger>) | 0    | 1     | 1     | 1    |
| expr.Ele.isOne()                                  | 4    | 1     | 4     | 6    |
| expr.Ele.isZero()                                 | 0    | 1     | 1     | 1    |
| expr.Ele.setCoe(BigInteger)                       | 0    | 1     | 1     | 1    |
| expr.Ele.setHashVar(String, BigInteger)           | 0    | 1     | 1     | 1    |
| expr.Ele.zero()                                   | 0    | 1     | 1     | 1    |
| expr.Expr.combTerm(ArrayList, String)             | 1    | 1     | 2     | 2    |
| expr.Expr.getExprList()                           | 0    | 1     | 1     | 1    |
| expr.Expr.initExpr(Ele)                           | 0    | 1     | 1     | 1    |
| expr.Expr.initExprList(ArrayList)                 | 0    | 1     | 1     | 1    |
| expr.Expr.merge()                                 | 10   | 4     | 7     | 7    |
| expr.Expr.mulTerm(ArrayList)                      | 3    | 1     | 3     | 3    |
| expr.Expr.reverse()                               | 1    | 1     | 2     | 2    |
| expr.Expr.reverseList(ArrayList)                  | 1    | 1     | 2     | 2    |
| expr.Expr.sort()                                  | 9    | 5     | 5     | 5    |
| expr.Expr.toString()                              | 16   | 1     | 10    | 11   |
| expr.Expr.varStr(Ele)                             | 21   | 1     | 16    | 16   |
| Total                                             | 118  | 49    | 109   | 117  |
| Average                                           | 3.47 | 1.44  | 3.21  | 3.44 |

##### ç±»å¤æåº¦

![](https://pic.superbed.cc/item/66ab48a1fcada11d37645283.png)

è¡¨ä¸­å¯ä»¥çåºæå¤æçä¸ä¸ªæ¹æ³ï¼`Parser.parseFactor()`ï¼`expr.Expr.toString()`å`expr.Expr.varStr(Ele)`ãç±äºå å­çå¯è½ç±»åè¾å¤ï¼è®¨è®ºæåµè¾å¤ï¼å æ­¤å¤æåº¦ä¹è¾é«ãåä¸¤èé½æ¯è½¬åä¸ºå­ç¬¦ä¸²çæ¹æ³ï¼ç±äºæåµç§ç±»è¾å¤ï¼å æ­¤å¤æåº¦ä¸åè¾æ¾èã

å¾ä¸­ä¹è½çå°`Expr`ç±»ï¼`Ele`ç±»å`Parser`ç±»çå¤æåº¦è¾é«ï¼`Parser`ç±»ä¸­åè§£çæ¹æ³è¾å¤ï¼`Expr`å`Ele`ä¸­è®¡ç®åå¹¶ä¹ç±»çæ¹æ³è¾å¤å¯¼è´äºè¿å ä¸ªç±»çå¤æåº¦è¾é«ã

###### éï¼åº¦éåææ¡ç®è§£é

- CogCï¼è®¤ç¥å¤æåº¦
- ev(G)ï¼éæ½è±¡æ¹æ³çåºæ¬å¤æåº¦ï¼ç¨ä»¥è¡¡éä¸ä¸ªæ¹æ³çæ§å¶æµç»æç¼ºé·ï¼èå´æ¯ [1, v(G)]
- iv(G)ï¼æ¹æ³çè®¾è®¡å¤æåº¦ï¼ç¨ä»¥è¡¡éæ¹æ³æ§å¶æµä¸å¶ä»æ¹æ³ä¹é´çè¦åç¨åº¦ï¼èå´æ¯ [1, v(G)]
- v(G)ï¼éæ½è±¡æ¹æ³çåå¤æåº¦ï¼ç¨ä»¥è¡¡éæ¯ä¸ªæ¹æ³ä¸­ä¸åæ§è¡è·¯å¾çæ°é
- OCï¼ç±»çéæ½è±¡æ¹æ³åå¤æåº¦ï¼ç»§æ¿ç±»ä¸è®¡å¥
- WMCï¼ç±»çæ»åå¤æåº¦

#### UMLç±»å¾

![](https://pic.superbed.cc/item/66ab48bafcada11d37646547.jpg)

æ¯ä¸ªç±»çè®¾è®¡èèå·²å¨ä¸æçè®¾è®¡ä¸æ¶æä¸­è¯´æï¼æ­¤å¤ä¸åèµè¿°ã

## ç¬¬äºæ¬¡ä½ä¸æ»ç»

### è®¾è®¡ä¸æ¶æ

æ¬æ¬¡ä½ä¸æ°å¢äºè¿äºè¦æ±ï¼

- æ¯æåµå¥å¤å±æ¬å·
- æ°å¢ä¸è§å½æ°å å­ï¼ä¸è§å½æ°æ¬å·åé¨åå«ä»»æå å­
- æ°å¢èªå®ä¹å½æ°å å­ï¼ä½èªå®ä¹å½æ°çå½æ°è¡¨è¾¾å¼ä¸­ä¸ä¼è°ç¨å¶ä»å½æ°

å æ­¤å¨ç¬¬ä¸æ¬¡ä½ä¸çåºç¡ä¸ï¼éè¦å®æè¿äºå·¥ä½ï¼

1. æ¿æ¢èªå®ä¹å½æ°
2. å¼å¥æ°çæ°æ®ç»æè½å¤å­å¨ä¸è§å å­
3. å¢å æå®åæ¹æ³å¹¶å®æä¸è§å½æ°çè®¡ç®ä¸åç®

#### æ¿æ¢èªå®ä¹å½æ°

##### `DeFun`

ä»ä»å®ç°æ¿æ¢ï¼æ¿æ¢ä¹åå³å¯æç§ä¹åçéå½ä¸éå®ç°è¡¨è¾¾å¼è§£æï¼

![](https://pic.superbed.cc/item/66ab48d0fcada11d376472dd.png)

- æ ¹æ®'='åå²æå·¦å³ä¸¤å­ç¬¦ä¸²ï¼å·¦è¾¹çå¯æ ¹æ®','æ¾åºå½¢åï¼å°å½¢ååå³è¾¹çè¡¨è¾¾å¼å­å¥`HashMap`
- å¨åè¡¨è¾¾å¼ä¸­éè¿`process()`æ¿æ¢ææçèªå®ä¹å½æ°

#### å¤çä¸è§å å­

##### `Ele`

æ¬æ¬¡ä½ä¸æ¯ä¸ª`Ele`ç±»ååºå½¢å¦ï¼

![](https://pic.superbed.cc/item/66ab48e7fcada11d376484ba.png)

å°ä¸è§å å­æ¬å·åé¨çå å­`toString`ä½ä¸º`key`ï¼ææ°ä½ä¸º`value`åå­å¥`HashMap`ï¼

![](https://pic.superbed.cc/item/66ab48f9fcada11d376494b9.png)

å¢å äºå¤çä¸è§å å­çæ¹æ³ï¼

![](https://pic.superbed.cc/item/66ab490cfcada11d3764a49b.png)

##### `Expr`

å æ³åä¹æ³åªéå¨åæåºç¡ä¸æ·»å ä¸è§å å­çè¿ç®å³å¯ï¼å æ³ä¹æ³éè¦å¨`canMerge()`ä¸­æ·»å æ¡ä»¶)ã

![](https://pic.superbed.cc/item/66ab492efcada11d3764be2f.png)

å¨`toString()`ä¸­å ä¸æå°ä¸è§å å­çæ¹æ³`triStr(Ele)`ã

### åºäºåº¦éçç¨åºç»æåæ

#### ä»£ç è§æ¨¡åæ

![](https://pic.superbed.cc/item/66ab494cfcada11d3764d335.png)

æ ¸å¿ä»£ç å¨742è¡å·¦å³ï¼`Expr`ç±»è¡æ°æå¤ï¼å å°äº259è¡ï¼å¶æ¬¡æ¯150è¡çè§£æ`Parser`ç±»ã

#### å¤æåº¦åæ

##### æ¹æ³å¤æåº¦

| Method                                            | CogC | ev(G) | iv(G) | v(G) |
| :------------------------------------------------ | :--- | :---- | :---- | :--- |
| DeFun.max(int, int)                               | 0    | 1     | 1     | 1    |
| DeFun.process(String)                             | 22   | 6     | 13    | 13   |
| DeFun.readFun(String)                             | 6    | 3     | 5     | 6    |
| Lexer.Lexer(String)                               | 0    | 1     | 1     | 1    |
| Lexer.getNumber()                                 | 2    | 1     | 3     | 3    |
| Lexer.next()                                      | 5    | 2     | 3     | 6    |
| Lexer.read()                                      | 0    | 1     | 1     | 1    |
| MainClass.main(String[])                          | 2    | 1     | 3     | 3    |
| Parser.Parser(Lexer)                              | 0    | 1     | 1     | 1    |
| Parser.dealEx(Expr)                               | 0    | 1     | 1     | 1    |
| Parser.parseExpr()                                | 5    | 1     | 5     | 5    |
| Parser.parseFactor()                              | 18   | 5     | 11    | 12   |
| Parser.parsePow()                                 | 2    | 1     | 2     | 2    |
| Parser.parseTerm()                                | 9    | 1     | 6     | 7    |
| Parser.parseTri()                                 | 8    | 1     | 4     | 4    |
| PreStr.pre(String)                                | 6    | 1     | 6     | 7    |
| expr.Ele.Ele()                                    | 0    | 1     | 1     | 1    |
| expr.Ele.canMerge(Ele)                            | 4    | 1     | 4     | 6    |
| expr.Ele.compareTo(Object)                        | 27   | 13    | 12    | 13   |
| expr.Ele.getCoe()                                 | 0    | 1     | 1     | 1    |
| expr.Ele.getHashCos()                             | 0    | 1     | 1     | 1    |
| expr.Ele.getHashSin()                             | 0    | 1     | 1     | 1    |
| expr.Ele.getHashVar()                             | 0    | 1     | 1     | 1    |
| expr.Ele.initHashCos(HashMap<String, BigInteger>) | 0    | 1     | 1     | 1    |
| expr.Ele.initHashSin(HashMap<String, BigInteger>) | 0    | 1     | 1     | 1    |
| expr.Ele.initHashVar(HashMap<String, BigInteger>) | 0    | 1     | 1     | 1    |
| expr.Ele.isOne()                                  | 6    | 1     | 5     | 8    |
| expr.Ele.isZero()                                 | 0    | 1     | 1     | 1    |
| expr.Ele.putHashCos(HashMap<String, BigInteger>)  | 4    | 1     | 3     | 3    |
| expr.Ele.putHashSin(HashMap<String, BigInteger>)  | 4    | 1     | 3     | 3    |
| expr.Ele.setCoe(BigInteger)                       | 0    | 1     | 1     | 1    |
| expr.Ele.setHashCos(String, BigInteger)           | 0    | 1     | 1     | 1    |
| expr.Ele.setHashSin(String, BigInteger)           | 0    | 1     | 1     | 1    |
| expr.Ele.setHashVar(String, BigInteger)           | 0    | 1     | 1     | 1    |
| expr.Ele.zero()                                   | 0    | 1     | 1     | 1    |
| expr.Expr.combTerm(ArrayList, String)             | 1    | 1     | 2     | 2    |
| expr.Expr.getExprList()                           | 0    | 1     | 1     | 1    |
| expr.Expr.initExpr(Ele)                           | 0    | 1     | 1     | 1    |
| expr.Expr.initExprList(ArrayList)                 | 0    | 1     | 1     | 1    |
| expr.Expr.merge()                                 | 10   | 4     | 7     | 7    |
| expr.Expr.mulTerm(ArrayList)                      | 3    | 1     | 3     | 3    |
| expr.Expr.reverse()                               | 1    | 1     | 2     | 2    |
| expr.Expr.reverseList(ArrayList)                  | 1    | 1     | 2     | 2    |
| expr.Expr.simplify()                              | 4    | 3     | 4     | 4    |
| expr.Expr.sort()                                  | 32   | 13    | 12    | 13   |
| expr.Expr.toString()                              | 16   | 1     | 10    | 11   |
| expr.Expr.triStr(Ele)                             | 14   | 1     | 11    | 11   |
| expr.Expr.varStr(Ele)                             | 21   | 1     | 16    | 16   |
| expr.Term.getTermList()                           | 0    | 1     | 1     | 1    |
| Total                                             | 233  | 90    | 180   | 195  |
| Average                                           | 4.75 | 1.83  | 3.67  | 3.97 |

##### ç±»å¤æåº¦

![](https://pic.superbed.cc/item/66ab4967fcada11d3764e765.png)

#### UMLç±»å¾

![](https://pic.superbed.cc/item/66ab4989fcada11d37650132.jpg)

æ¯ä¸ªç±»çè®¾è®¡èèå·²å¨ä¸æçè®¾è®¡ä¸æ¶æä¸­è¯´æï¼æ­¤å¤ä¸åèµè¿°ã

## ç¬¬ä¸æ¬¡ä½ä¸æ»ç»

### è®¾è®¡ä¸æ¶æ

æ¬æ¬¡ä½ä¸æ°å¢äºè¿äºè¦æ±ï¼

- èªå®ä¹å½æ°å®ä¹æ¶å¯ä»¥è°ç¨å·²ç»å®ä¹è¿çèªå®ä¹å½æ°
- æ°å¢æ±å¯¼å å­

å æ­¤ï¼å¨ç¬¬äºæ¬¡ä½ä¸çåºç¡ä¸ï¼éè¦å®æè¿äºå·¥ä½ï¼

1. å¨`DeFun`ç±»ä¸­å®åæ¹æ³ä½¿æ¯æè°ç¨å®ä¹è¿çèªå®ä¹å½æ°å¹¶ä¸åå«æ±å¯¼å å­
2. å¨`Expr`ç±»ä¸­æ°å¢æ±å¯¼çæ¹æ³

#### å®åæ¿æ¢èªå®ä¹å½æ°çæ¹æ³

##### `DeFun`

å¨åä¸ä¸ªç±»ä¸­æ¿æ¢å·²ç»å­å¨äºHashMapä¸­çèªå®ä¹å½æ°ï¼ç¶åæ¿æ¢æ±å¯¼å å­ï¼æ ¹æ®é¢ç®è¦æ±ï¼éè¦å¨è¿éå°æ±å¯¼å å­åç®å¹¶æ¿æ¢ï¼ï¼å æ­¤æä»¬ç´æ¥å¤ç¨ä¹åçParserç±»è§£ææ±å¯¼å å­åé¨çè¡¨è¾¾å¼ï¼å¹¶ä¸ç¨`toString()`æ¿æ¢åæ±å¯¼å å­ã

ä¸é¢æ¯å¯è½çç¤ºä¾ï¼

```java
if (str.contains("d")) { //æ±å¯¼å å­åªåºç°ä¸æ¬¡
            int begin = str.indexOf("d");
            //subString = dx(è¡¨è¾¾å¼) | dy(è¡¨è¾¾å¼) | dz(è¡¨è¾¾å¼)ï¼æ¯æ±å¯¼å å­
            String subString = sim.substring(/*å°dx()ædy()ædz()çå­ä¸²æååºæ¥*/);
            String derFact = subString.substring(2); //derFactæ¯éè¦æ±å¯¼çè¡¨è¾¾å¼
            parser.parseExpr();//é¢å¤çï¼è§£æï¼è¿åä¸ä¸ªExprç±»
            expr.derExpr();//æ¬å·åçè¡¨è¾¾å¼è¿è¡æ±å¯¼è½å¤è¿åä¸ä¸ªExprç±»
            str = str.replace(subString, "(" + expr + ")"); //å°æ´ä¸ªæ±å¯¼å å­åé¤ï¼æ¿æ¢ï¼
        }
```

#### å¢å æ±å¯¼çæ¹æ³

##### `Ele`

å¨`Ele`ä¸­å¢å æ¹æ³æ¯æå¤æ­è¯¥`Ele`æ¯å¦åå«è¯¥åéï¼'x','y','z')ï¼è¥ä¸åå«ï¼åæ±å¯¼çç»æä¸ºé¶ï¼åä¹åå¯è¿è¡æ­£å¸¸çæ±å¯¼ã

![](https://pic.superbed.cc/item/66ab49b0fcada11d37651f94.png)

##### `Expr`

å¢å æ¯ææ±å¯¼çæ¹æ³ï¼`derExpr(char)`ä¸­å¯¹åæ°`char`ä½ä¸ºèªåéæ±å¯¼ï¼åå«å¯¹æ¯ä¸ä¸ª`Ele`çåéé¨åï¼ä¸è§å å­é¨åè¿è¡æ±å¯¼ååå¹¶ã

![](https://pic.superbed.cc/item/66ab49c5fcada11d37652fa1.png)

### åºäºåº¦éçç¨åºç»æåæ

#### ä»£ç è§æ¨¡åæ

![](https://pic.superbed.cc/item/66ab49dcfcada11d376541d1.png)

æ ¸å¿ä»£ç å¨899è¡å·¦å³ï¼`Expr`ç±»è¡æ°æå¤ï¼å å°äº370è¡ï¼å¶æ¬¡æ¯173è¡çè§£æ`Expr`ç±»ã

#### å¤æåº¦åæ

##### æ¹æ³å¤æåº¦

| Method                                       | CogC | ev(G) | iv(G) | v(G) |
| :------------------------------------------- | :--- | :---- | :---- | :--- |
| DeFun.findRi(int, String)                    | 9    | 5     | 6     | 6    |
| DeFun.max(int, int)                          | 0    | 1     | 1     | 1    |
| DeFun.process(String)                        | 10   | 1     | 8     | 8    |
| DeFun.readFun(String)                        | 7    | 3     | 6     | 7    |
| Ele.Ele()                                    | 0    | 1     | 1     | 1    |
| Ele.canMerge(Ele)                            | 4    | 1     | 4     | 6    |
| Ele.compareTo(Object)                        | 27   | 13    | 12    | 13   |
| Ele.cosContain(String)                       | 3    | 3     | 2     | 3    |
| Ele.getCoe()                                 | 0    | 1     | 1     | 1    |
| Ele.getHashCos()                             | 0    | 1     | 1     | 1    |
| Ele.getHashSin()                             | 0    | 1     | 1     | 1    |
| Ele.getHashVar()                             | 0    | 1     | 1     | 1    |
| Ele.initHashCos(HashMap<String, BigInteger>) | 0    | 1     | 1     | 1    |
| Ele.initHashSin(HashMap<String, BigInteger>) | 0    | 1     | 1     | 1    |
| Ele.initHashVar(HashMap<String, BigInteger>) | 0    | 1     | 1     | 1    |
| Ele.isOne()                                  | 6    | 1     | 5     | 8    |
| Ele.isZero()                                 | 0    | 1     | 1     | 1    |
| Ele.putHashCos(HashMap<String, BigInteger>)  | 4    | 1     | 3     | 3    |
| Ele.putHashSin(HashMap<String, BigInteger>)  | 4    | 1     | 3     | 3    |
| Ele.setCoe(BigInteger)                       | 0    | 1     | 1     | 1    |
| Ele.setHashCos(String, BigInteger)           | 0    | 1     | 1     | 1    |
| Ele.setHashSin(String, BigInteger)           | 0    | 1     | 1     | 1    |
| Ele.setHashVar(String, BigInteger)           | 0    | 1     | 1     | 1    |
| Ele.sinContain(String)                       | 3    | 3     | 2     | 3    |
| Ele.varContain(String)                       | 1    | 1     | 1     | 2    |
| Ele.zero()                                   | 0    | 1     | 1     | 1    |
| Expr.combTerm(ArrayList, String)             | 1    | 1     | 2     | 2    |
| Expr.derCos(int, String)                     | 7    | 1     | 5     | 5    |
| Expr.derExpr(char)                           | 14   | 1     | 8     | 8    |
| Expr.derSin(int, String)                     | 7    | 1     | 5     | 5    |
| Expr.derVar(int, String)                     | 0    | 1     | 1     | 1    |
| Expr.getExprList()                           | 0    | 1     | 1     | 1    |
| Expr.initExpr(Ele)                           | 0    | 1     | 1     | 1    |
| Expr.initExprList(ArrayList)                 | 0    | 1     | 1     | 1    |
| Expr.merge()                                 | 10   | 4     | 7     | 7    |
| Expr.mulTerm(ArrayList)                      | 3    | 1     | 3     | 3    |
| Expr.reverse()                               | 1    | 1     | 2     | 2    |
| Expr.reverseList(ArrayList)                  | 1    | 1     | 2     | 2    |
| Expr.simplify()                              | 4    | 3     | 4     | 4    |
| Expr.sort()                                  | 32   | 13    | 12    | 13   |
| Expr.toString()                              | 16   | 1     | 10    | 11   |
| Expr.triStr(Ele)                             | 22   | 1     | 13    | 13   |
| Expr.varStr(Ele)                             | 21   | 1     | 16    | 16   |
| Lexer.Lexer(String)                          | 0    | 1     | 1     | 1    |
| Lexer.getNumber()                            | 2    | 1     | 3     | 3    |
| Lexer.next()                                 | 6    | 2     | 6     | 7    |
| Lexer.read()                                 | 0    | 1     | 1     | 1    |
| MainClass.main(String[])                     | 2    | 1     | 3     | 3    |
| Parser.Parser(Lexer)                         | 0    | 1     | 1     | 1    |
| Parser.dealEx(Expr)                          | 0    | 1     | 1     | 1    |
| Parser.parseDer(char)                        | 0    | 1     | 1     | 1    |
| Parser.parseExpr()                           | 5    | 1     | 5     | 5    |
| Parser.parseFactor()                         | 20   | 6     | 14    | 15   |
| Parser.parsePow()                            | 2    | 1     | 2     | 2    |
| Parser.parseTerm()                           | 9    | 1     | 6     | 7    |
| Parser.parseTri()                            | 8    | 1     | 4     | 4    |
| PreStr.pre(String)                           | 6    | 1     | 6     | 7    |
| Total                                        | 277  | 102   | 214   | 230  |
| Average                                      | 4.85 | 1.79  | 3.75  | 4.04 |

##### ç±»å¤æåº¦

![](https://pic.superbed.cc/item/66ab49f4fcada11d3765538f.png)

å¾ä¸­ä¹è½çå°`Expr`ç±»ï¼`Ele`ç±»å`Parser`ç±»çå¤æåº¦è¾é«ï¼Exprç±»ä¸­å¤§éçåç®ãè®¡ç®åæ±å¯¼æ¹æ³ä½¿å¾è¯¥ç±»å¤æåº¦å¾é«ã

#### UMLç±»å¾

![](https://pic.superbed.cc/item/66ab4a0bfcada11d37656557.jpg)

æ¯ä¸ªç±»çè®¾è®¡èèå·²å¨ä¸æçè®¾è®¡ä¸æ¶æä¸­è¯´æï¼æ­¤å¤ä¸åèµè¿°ã

## bugåæ

### åæèªå·±ç¨åºçbug

##### ç¬¬ä¸æ¬¡ä½ä¸

- ä¸äºç¹æ®ç¹çæåµï¼ä¾å¦ï¼0^0+5^0+2*10^0ï¼éè¦æååå¥½è°è¯å¹¶å¨`toString()`ä¸­ä¿®æ¹

##### ç¬¬äºæ¬¡ä½ä¸

- æ¿æ¢èªå®ä¹å½æ°æ¶æ ¹æ®éå·åå²ï¼å æ­¤å¨é¢å¯¹åµå¥å½æ°ä¾å¦f(g(y,z),h(x,y),sin(x))ä¸­å­å¨å¤äº2ä¸ªéå·çæåµå¯è½ä¼åºéï¼è§£å³æ¹æ¡æ¯æ¯æ¬¡å¾ªç¯æ¾å°æé åçä¸ä¸ªèªå®ä¹å½æ°ï¼ä¿è¯è¿ä¸ªå½æ°éå¼å°æ²¡æåµå¥çèªå®ä¹ï¼è¿è¡æ¿æ¢
- æ³¨ææ¿æ¢æ¶ç´¢å¼çä½ç½®ï¼ä¾å¦f((((x,y,z))))å¯è½ä¼åºç°æ¬å·å¤æ­éè¯¯
- æ³¨æç¹æ®åè¾¹çç¹ï¼ä¾å¦sin((0))^2,sin((0))^0,cos((0))^3
- å¹æ¬¡ä¸º0æ¶åºè¯¥ç´æ¥è¯»åæ´æ°èä¸æ¯å¾åè§£æè¡¨è¾¾å¼ï¼å¤§æ¦æ¯èå­æ½äºæè¿æ ·åï¼å¤§é¨åç±»ä¼¼çé®é¢å¨é½æ¯è¿ç¹å¼èµ·çï¼

##### ç¬¬ä¸æ¬¡ä½ä¸

- æ±å¯¼ä¹ååç®ä¼åºé®é¢ï¼ä¾å¦dx(x*cos(x)**0)æåè§£æå¾å°çExpræ²¡æé®é¢ä½æ¯è¾åºä¼åºéï¼åå å¨äºæå¤æ­cosé¨åå«ä¸å«xæ¯æ ¹æ®HashMapæ¯å¦ä¸ºç©ºï¼ç¬¬äºæ¬¡ä½ä¸çéçï¼ï¼ä½æ¯å¨æ±å¯¼ä¹åææ²¡æè¿è¡ç¸åºçremoveå·¥ä½ï¼å¯¼è´è¾åºéè¯¯

### åæä»äººç¨åºçbug

æå¨æé å·æä»£è¡¨æ§çè¾¹çæ°æ®ï¼æ¥æå¤å±åµå¥æ¬å·ï¼åæ¶åå«ç¹æ®æ¡ä»¶ï¼ç»æä¸º0ï¼1ï¼æ±å¯¼åé¨æ èªåéï¼ï¼ä¾å¦ï¼

```javascript
1
f(x,y)=(((sin(cos(x))-(+1-sin(cos(y))))))
f((sin(x)),(y**2-0**0))+cos(0)**0-sin(0)**0
0
dx(x*cos(x)**0)
```

## å¿å¾ä½ä¼

ç¬¬ä¸ååä½ä¸ä¸»è¦æ¯éå¯¹è¡¨è¾¾å¼æ¬å·å±å¼åæ±å¯¼çä¸æ¬¡è¿­ä»£å¼åãä»æå¼å§çä¸çè§£gitçä½ç¨ï¼å°ç°å¨æ¸æ¸è®¤è¯å°çæ¬ç®¡çå¨å·¥ç¨ä¸­çéè¦æ§ï¼ä»å¯¹IDEAçæ æéä»åå±¡æ¬¡ç¯éï¼å°éæ¸é¢ç¥å°è¿æ¬¾IDEåè½çå¼ºå¤§ï¼ä»æå¼å§çå¯¹Javaæå°éçï¼å°éæ¸çæå®çä¼å¤ä¼è¯ç®ä¾¿çæ¹æ³ãæ°æ®ç»æåå¶é¢åå¯¹è±¡çæç»´ãåæ¶ï¼ä¸æ¬¡ä½ä¸å¯¹ä»£ç é£æ ¼çè¦æ±ä½¿æè¿ä¸æ­¥æè¯å°ç é£çéè¦æ§å¹¶éæ¸åå¨å°æåäºèªå·±ç¼ç¨çç é£ãç¬¬ä¸æ¬¡ä½ä¸ç±äºåªææ´ä½çæ¶æï¼å¨ç¼ºå°å¯¹Javaè¯­æ³ä»¥åæ°æ®ç»æç­ç¥è¯çç¼ºä¹çæåµä¸ï¼å®æå¾éå¸¸è°é¾ãå¨ç¬¬äºæ¬¡ç¬¬ä¸æ¬¡çè¿­ä»£å¼åä¸­ï¼ä»»å¡éææ¾æ¯ç¬¬ä¸æ¬¡çä»é¶å¼å§è¦è½»æ¾ä¸äºï¼ä½æ¯è¦ç¹å«ç¹å«æ³¨æç±»ä»¥åæ¹æ³ä¹é´çè¦åæ§ï¼å°½éä¸æ¹åç°æçæ¹æ³ï¼è¿æ ·æ´å®¹æåç°ä»£ç çbugãæåï¼æè®¤ä¸ºå¯ä»¥å¤åèè®¨è®ºåºéåå­¦ä»¬çè®¾è®¡æè·¯ï¼è¿å¯¹äºæçæ¶æè®¾è®¡æå¾å¤§çå¸®å©^_^ æè°¢å©æååå­¦ä»¬çç­å¿å¸®å©ï¼
